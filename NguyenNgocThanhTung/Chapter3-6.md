**Ca kiểm thử không gây ra lỗi (fault):**
Gọi phương thức ``computePrime(n)`` với ``n = 0``, với đầu vào (input) của phương thức là ``0``, thì sẽ không bao giờ chương trình chạy được vào vòng ``while(count<=n)`` bởi vì biến ``count`` khởi tạo bằng ``1`` luôn lớn hơn ``0``.
**Ca kiểm thử gây ra lỗi, nhưng lỗi đó không bị lây nhiễm (infect):**
Gọi phương thức ``computePrime(n)`` với ``n = 3``, chương trình sẽ chạy qua đoạn mã nguồn mà có lỗi, nhưng do thực tế 3 số nguyên tố đầu tiên là 2, 3, 5, và không có số nguyên tố nào trong 3 số trên có chữ số cuối cùng là 9 cả, nên là lỗi không bị lây nhiễm.
**Ca kiểm thử làm cho lỗi bị lây nhiễm, nhưng không được truyền đi (propagate):**
Gọi phương thức ``computePrime(n)`` với ``n = 10``, chương trình sẽ chạy qua đoạn mã nguồn mà có lỗi, lỗi sẽ bị lây nhiễm, vì chương trình sẽ không in ra được số 19, nhưng nếu không gọi phương thức ``toString()`` thì lỗi đó sẽ không bị truyền đi (propagate), sẽ không bị nhận ra bởi người dùng.
**Ca kiểm thử được truyền đi nhưng chưa được tiết lộ (reveal):**
Gọi phương thức ``computePrime(n)`` với ``n = 10``, chương trình sẽ chạy qua đoạn mã nguồn mà có lỗi, lỗi sẽ bị lây nhiễm, vì chương trình sẽ không in ra được số 19, sau đó gọi phương thức ``toString()`` thì lỗi đó sẽ được truyền đi (propagate), nếu người không nhận ra điều sai lệnh này (là điều: trong kết quả không có số 19), thì lỗi này không được tiết lộ (reveal).
**Ca kiểm thử làm cho lỗi được tiết lộ (reveal):**
Gọi phương thức ``computePrime(n)`` với ``n = 10``, chương trình sẽ chạy qua đoạn mã nguồn mà có lỗi, lỗi sẽ bị lây nhiễm, vì chương trình sẽ không in ra được số 19, sau đó gọi phương thức ``toString()`` thì lỗi đó sẽ được truyền đi (propagate), nếu người nhận ra điều sai lệnh này (là điều: trong kết quả không có số 19) bằng cách so sánh với kết quả của các ca kiểm thử tương đồng (ca kiểm thử có cùng đầu vào), thì lỗi này được tiết lộ (reveal).